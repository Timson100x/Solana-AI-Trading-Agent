/**
 * Natural Language Command Handler - ElizaOS V2
 * Parst NL-Commands wie "baue einen gridbot" und generiert Code
 */

import { Logger } from "../utils/logger.js";
import axios from "axios";

const logger = new Logger("NL-Commands");

export class NLCommandHandler {
  constructor(aiProvider) {
    this.ai = aiProvider;
    this.commands = this.initializeCommands();
  }

  initializeCommands() {
    return {
      // Grid Bot
      gridbot: {
        keywords: ["grid", "gridbot", "grid bot", "arbitrage"],
        template: "grid-trading-bot",
        description: "Grid Trading Bot mit automatischen Buy/Sell Orders",
      },
      // DCA Bot
      dcabot: {
        keywords: ["dca", "dollar cost", "durchschnitt", "regelm√§√üig"],
        template: "dca-bot",
        description: "Dollar Cost Averaging Bot",
      },
      // Sniper Bot
      sniper: {
        keywords: ["snipe", "sniper", "launch", "new token"],
        template: "sniper-bot",
        description: "Token Launch Sniper Bot",
      },
      // Copy Trading
      copytrader: {
        keywords: ["copy", "follow", "mirror", "smart wallet"],
        template: "copy-trading-bot",
        description: "Copy Trading Bot (Smart Wallets folgen)",
      },
      // Arbitrage Bot
      arbitrage: {
        keywords: ["arbitrage", "profit", "price difference"],
        template: "arbitrage-bot",
        description: "DEX Arbitrage Bot",
      },
    };
  }

  /**
   * Parse Natural Language Command
   */
  async parse(input) {
    logger.info(`üß† Parsing NL command: "${input}"`);

    // 1. Detect command type
    const detectedCommand = this.detectCommand(input);

    if (!detectedCommand) {
      return {
        success: false,
        error: "Konnte keinen Bot-Typ erkennen",
        suggestions: Object.values(this.commands).map((c) => c.description),
      };
    }

    // 2. Extract parameters with AI
    const parameters = await this.extractParameters(input, detectedCommand);

    // 3. Generate code specification
    const spec = {
      type: detectedCommand.template,
      description: detectedCommand.description,
      parameters,
      timestamp: Date.now(),
      nlInput: input,
    };

    logger.success(`‚úÖ Parsed: ${detectedCommand.description}`);
    return { success: true, spec };
  }

  /**
   * Detect command from keywords
   */
  detectCommand(input) {
    const lower = input.toLowerCase();

    for (const [key, command] of Object.entries(this.commands)) {
      for (const keyword of command.keywords) {
        if (lower.includes(keyword)) {
          return command;
        }
      }
    }

    return null;
  }

  /**
   * Extract parameters using AI
   */
  async extractParameters(input, command) {
    const prompt = `
Extract trading bot parameters from this user request:
"${input}"

Bot Type: ${command.description}

Extract and structure these parameters in JSON:
{
  "token": "token symbol or mint if mentioned",
  "amount": "SOL amount if mentioned",
  "priceRange": "price range for grid bot (min-max)",
  "gridLevels": "number of grid levels",
  "interval": "time interval (e.g., 1h, 4h, daily)",
  "takeProfitPercent": "take profit percentage",
  "stopLossPercent": "stop loss percentage",
  "maxPositions": "max concurrent positions",
  "riskLevel": "low/medium/high"
}

Only include parameters that are explicitly mentioned or strongly implied.
Return valid JSON only, no explanations.
`;

    try {
      const response = await this.ai.generateText(prompt, {
        model: "gemini-2.0-flash-exp",
        temperature: 0.3,
        maxTokens: 512,
      });

      // Parse AI response
      const jsonMatch = response.text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }

      return {}; // No parameters extracted
    } catch (error) {
      logger.warn("‚ö†Ô∏è Parameter extraction failed:", error.message);
      return {};
    }
  }

  /**
   * Generate code from specification
   */
  async generateCode(spec) {
    logger.info(`üî® Generating code for: ${spec.type}`);

    const template = this.getTemplate(spec.type);
    const code = this.fillTemplate(template, spec);

    return {
      filename: `${spec.type}-${Date.now()}.js`,
      code,
      spec,
    };
  }

  /**
   * Get bot template
   */
  getTemplate(type) {
    const templates = {
      "grid-trading-bot": this.gridBotTemplate(),
      "dca-bot": this.dcaBotTemplate(),
      "sniper-bot": this.sniperBotTemplate(),
      "copy-trading-bot": this.copyTradingTemplate(),
      "arbitrage-bot": this.arbitrageBotTemplate(),
    };

    return templates[type] || templates["grid-trading-bot"];
  }

  /**
   * Grid Bot Template
   */
  gridBotTemplate() {
    return `/**
 * Grid Trading Bot - Auto-generated by ElizaOS
 * Generated: {{timestamp}}
 * Input: "{{nlInput}}"
 */

import "dotenv/config";
import { Connection, PublicKey } from "@solana/web3.js";
import { WalletService } from "./src/services/wallet.js";
import { JupiterService } from "./src/services/jupiter.js";
import { Logger } from "./src/utils/logger.js";

const logger = new Logger("GridBot");

class GridTradingBot {
  constructor(config) {
    this.config = config;
    this.connection = new Connection(process.env.RPC_ENDPOINT);
    this.wallet = new WalletService(this.connection);
    this.jupiter = new JupiterService(this.connection, this.wallet);
    this.gridLevels = [];
    this.activeOrders = new Map();
  }

  async initialize() {
    logger.info("üîß Initializing Grid Bot...");
    
    // Initialize grid levels
    const { minPrice, maxPrice, levels } = this.config;
    const priceStep = (maxPrice - minPrice) / (levels - 1);

    for (let i = 0; i < levels; i++) {
      const price = minPrice + (priceStep * i);
      this.gridLevels.push({
        price,
        buyOrder: null,
        sellOrder: null,
      });
    }

    logger.success(\`‚úÖ Grid initialized: \${levels} levels from \${minPrice} to \${maxPrice}\`);
  }

  async start() {
    logger.info("üöÄ Starting Grid Bot...");

    while (true) {
      try {
        const currentPrice = await this.getCurrentPrice();
        await this.updateOrders(currentPrice);
        await this.sleep(this.config.checkInterval || 30000);
      } catch (error) {
        logger.error("‚ùå Grid cycle error:", error);
        await this.sleep(60000);
      }
    }
  }

  async getCurrentPrice() {
    const quote = await this.jupiter.getQuote(
      this.config.token,
      "So11111111111111111111111111111111111111112", // SOL
      1000000 // 0.001 token
    );
    return quote.outAmount / 1000000;
  }

  async updateOrders(currentPrice) {
    logger.info(\`üìä Current Price: \${currentPrice}\`);

    for (const level of this.gridLevels) {
      // Place buy order below current price
      if (currentPrice > level.price * 1.01 && !level.buyOrder) {
        await this.placeBuyOrder(level);
      }

      // Place sell order above current price
      if (currentPrice < level.price * 0.99 && !level.sellOrder) {
        await this.placeSellOrder(level);
      }
    }
  }

  async placeBuyOrder(level) {
    try {
      logger.info(\`üìâ Placing buy order at \${level.price}\`);
      
      const result = await this.jupiter.buyToken(
        this.config.token,
        this.config.orderSize
      );

      level.buyOrder = {
        price: level.price,
        signature: result.signature,
        timestamp: Date.now(),
      };

      logger.success(\`‚úÖ Buy order placed: \${result.signature.slice(0, 8)}...\`);
    } catch (error) {
      logger.error("‚ùå Buy order failed:", error.message);
    }
  }

  async placeSellOrder(level) {
    try {
      logger.info(\`üìà Placing sell order at \${level.price}\`);
      
      const result = await this.jupiter.sellToken(
        this.config.token,
        this.config.orderSize
      );

      level.sellOrder = {
        price: level.price,
        signature: result.signature,
        timestamp: Date.now(),
      };

      logger.success(\`‚úÖ Sell order placed: \${result.signature.slice(0, 8)}...\`);
    } catch (error) {
      logger.error("‚ùå Sell order failed:", error.message);
    }
  }

  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

// Configuration from NL parsing
const config = {
  token: "{{token}}" || "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC default
  minPrice: {{minPrice}} || 50,
  maxPrice: {{maxPrice}} || 150,
  levels: {{gridLevels}} || 10,
  orderSize: {{amount}} || 0.01, // SOL per order
  checkInterval: 30000, // 30s
  riskLevel: "{{riskLevel}}" || "medium",
};

// Start bot
const bot = new GridTradingBot(config);
bot.initialize().then(() => bot.start());
`;
  }

  /**
   * DCA Bot Template
   */
  dcaBotTemplate() {
    return `/**
 * DCA Bot - Auto-generated by ElizaOS
 * Generated: {{timestamp}}
 */

import "dotenv/config";
import { Connection } from "@solana/web3.js";
import { WalletService } from "./src/services/wallet.js";
import { JupiterService } from "./src/services/jupiter.js";
import { Logger } from "./src/utils/logger.js";

const logger = new Logger("DCABot");

class DCABot {
  constructor(config) {
    this.config = config;
    this.connection = new Connection(process.env.RPC_ENDPOINT);
    this.wallet = new WalletService(this.connection);
    this.jupiter = new JupiterService(this.connection, this.wallet);
    this.purchaseHistory = [];
  }

  async start() {
    logger.info("üöÄ DCA Bot started");
    logger.info(\`Buying \${this.config.amount} SOL of \${this.config.token} every \${this.config.interval}\`);

    while (true) {
      try {
        await this.executePurchase();
        await this.sleep(this.parseInterval(this.config.interval));
      } catch (error) {
        logger.error("‚ùå DCA cycle error:", error);
        await this.sleep(60000);
      }
    }
  }

  async executePurchase() {
    logger.info("üí∞ Executing DCA purchase...");

    const result = await this.jupiter.buyToken(
      this.config.token,
      this.config.amount
    );

    this.purchaseHistory.push({
      timestamp: Date.now(),
      amount: this.config.amount,
      signature: result.signature,
      price: result.price,
    });

    logger.success(\`‚úÖ Purchased: \${result.signature.slice(0, 8)}...\`);

    // Calculate average price
    const avgPrice = this.purchaseHistory.reduce((sum, p) => sum + p.price, 0) / this.purchaseHistory.length;
    logger.info(\`üìä Average Buy Price: \${avgPrice}\`);
  }

  parseInterval(interval) {
    const units = { h: 3600000, m: 60000, s: 1000 };
    const match = interval.match(/(\\d+)([hms])/);
    return match ? parseInt(match[1]) * units[match[2]] : 3600000;
  }

  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

const config = {
  token: "{{token}}" || "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  amount: {{amount}} || 0.01,
  interval: "{{interval}}" || "4h",
};

const bot = new DCABot(config);
bot.start();
`;
  }

  /**
   * Sniper Bot Template (Professional)
   */
  sniperBotTemplate() {
    return `/**
 * Professional Sniper Bot - Auto-generated by ElizaOS
 * Generated: {{timestamp}}
 * Input: "{{nlInput}}"
 * Optimized for: Pump.fun Token Launches
 */

import "dotenv/config";
import { ProfessionalSniperBot } from "./src/bots/professional-sniper-bot.js";
import { Logger } from "./src/utils/logger.js";

const logger = new Logger("SniperMain");

// Sniper Configuration from NL parsing
const config = {
  // Target Settings
  targetLiquidity: {{targetLiquidity}} || 50,    // Min $50 liquidity
  maxLiquidity: {{maxLiquidity}} || 500,         // Max $500 (fr√ºh einsteigen)
  buyAmount: {{amount}} || 0.05,                 // SOL per snipe
  
  // Exit Strategy
  takeProfitPercent: {{takeProfitPercent}} || 200,  // 200% = 3x
  stopLossPercent: {{stopLossPercent}} || 50,       // -50% stop loss
  
  // Risk Management
  maxPositions: {{maxPositions}} || 3,           // Max 3 concurrent positions
  dailyMaxLoss: 0.2,                             // Max 0.2 SOL loss per day
  minHolders: 10,                                // Min 10 holders
  
  // Speed Optimization
  bundleEnabled: true,                           // Jito MEV protection
  skipVerification: false,                       // Quick snipes
  
  riskLevel: "{{riskLevel}}" || "medium",
};

// Main function
async function main() {
  logger.info("üéØ Initializing Professional Sniper Bot...");
  
  // Import main agent to access services
  const { default: agent } = await import("./index.js");
  
  // Wait for agent initialization
  await new Promise(resolve => setTimeout(resolve, 5000));
  
  // Create sniper bot
  const sniper = new ProfessionalSniperBot(config, agent);
  
  // Start sniping
  await sniper.start();
  
  // Handle shutdown
  process.on("SIGINT", async () => {
    logger.info("üõë Shutting down...");
    await sniper.stop();
    process.exit(0);
  });
}

// Run
main().catch(error => {
  logger.error("‚ùå Sniper bot crashed:", error);
  process.exit(1);
});
`;
  }

  copyTradingTemplate() {
    return `// Copy Trading Template - Simplified version`;
  }

  arbitrageBotTemplate() {
    return `// Arbitrage Template - Simplified version`;
  }

  /**
   * Fill template with actual values
   */
  fillTemplate(template, spec) {
    let code = template;

    // Replace placeholders
    code = code.replace(/\{\{timestamp\}\}/g, new Date().toISOString());
    code = code.replace(/\{\{nlInput\}\}/g, spec.nlInput);

    // Replace parameters
    for (const [key, value] of Object.entries(spec.parameters)) {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, "g");
      code = code.replace(regex, value || "");
    }

    return code;
  }
}
